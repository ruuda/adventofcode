let data = std.read_file_utf8("input.txt");
let edges = data
  .split("\n\n")[0]
  .split_lines()
  .map(line => line.split("|").map(x => x.parse_int()));
let books = data
  .split("\n\n")[1]
  .split_lines()
  .map(line => line.split(",").map(x => x.parse_int()));

// Map every page number to the pages that must be ordered after it.
let rules: Dict[Int, Set[Int]] = {
  for k, v in edges.group_by(edge => edge[0]): k: {for edge in v: edge[1]}
};

let middle_pages = [
  for book in books:
  let violations = [
    for i, page in book.enumerate():
    for j in std.range(0, i):
    let page_before = book[j];
    let page_must_after: Set[Int] = rules.get(page, std.empty_set);
    if page_must_after.contains(page_before):
    // If the set of pages that must go after `page` contains a page that goes
    // before it, then this book is bad. A non-empty list means the set of
    // violations is not empty, so we just need to return *something* here.
    1
  ];
  // We are only interested in books without violations, and then we need the
  // middle page number.
  if violations.len() == 0:
  book[(book.len() - 1) / 2]
];

middle_pages.sum()
