let corners = [
  for line in std.read_file_utf8("input.txt").split_lines():
  line.split(",").map(x => x.parse_int())
];

let abs = x => if x < 0: -x else: x;
let minmax = (x, y) => if x < y: [x, y] else: [y, x];

let areas_part1 = [
  for i, c1 in corners.enumerate():
  for j in std.range(i + 1, corners.len()):
  let c2 = corners[j];
  let w = abs(c2[0] - c1[0]) + 1;
  let h = abs(c2[1] - c1[1]) + 1;
  w * h
];

// Horizontal or vertical connections between two endpoints.
// Excludes the endpoints themselves.
let path = (c1, c2) =>
  if c2[0] == c1[0]:
    let bounds = minmax(c1[1], c2[1]);
    std.range(bounds[0] + 1, bounds[1]).map(y => [c1[0], y])
  else:
    let bounds = minmax(c1[0], c2[0]);
    std.range(bounds[0] + 1, bounds[1]).map(x => [x, c1[1]]);

let outline = {
  for i, c2 in corners.enumerate():
  let c1 = corners[i - 1];
  ..path(c1, c2),
  ..corners,
};

// Now we compute a flood-fill of the outer region.
let area_w = corners.map(p => p[0]).sort()[-1] + 1;
let area_h = corners.map(p => p[1]).sort()[-1] + 1;
let offsets = [
  for dx in [-1, 0, 1]:
  for dy in [-1, 0, 1]:
  if dx != dy:
  [dx, dy]
];

let iter = (state, _i) =>
  let closed = { ..state.closed, ..state.frontier };
  {
    closed = closed,
    frontier = {
      for p in state.frontier:
      for d in offsets:

      let qx = p[0] + d[0];
      if qx >= 0:
      if qx <= area_w:

      let qy = p[1] + d[1];
      if qy >= 0:
      if qy <= area_h:

      let q = [qx, qy];
      if not closed.contains(q):
      if not outline.contains(q):
      q
    },
  };

// We could seed the frontier with just (0, 0), but then it grows more slowly at
// every step; if we seed it with all corners it converges faster. If we seed it
// with the full outline then it grows _even faster_. But iterating lists counts
// towards the budget too so this is no use ...
let seed_frontier = {
  [0, 0],
  ..path([0, 0], [0, area_h]),
  [0, area_h],
  ..path([0, area_h], [area_w, area_h]),
  [area_w, area_h],
  ..path([area_w, area_h], [area_w, 0]),
  [area_w, 0],
  ..path([area_w, 0], [0, 0]),
};
let fixed_point_state = std
  .range(0, 10)
  .fold(
    { frontier = seed_frontier, closed = std.empty_set },
    iter,
  );

assert fixed_point_state.frontier.len() == 0:
  f"""
  At a fixed point the frontier should be empty,
  but here it has {fixed_point_state.frontier.len()} items still!
  """;

let outer = fixed_point_state.closed;

let is_inside = (c1, c2) =>
  let xs = minmax(c1[0], c2[0]);
  let ys = minmax(c1[1], c2[1]);
  let points = [
    for x in std.range(xs[0], xs[1] + 1):
    for y in std.range(ys[0], ys[1] + 1):
    [x, y]
  ];
  not points.any(outer.contains);

let areas_part2 = [
  for i, c1 in corners.enumerate():
  for j in std.range(i + 1, corners.len()):
  let c2 = corners[j];
  if is_inside(c1, c2):
  let w = abs(c2[0] - c1[0]) + 1;
  let h = abs(c2[1] - c1[1]) + 1;
  w * h
];

{
  part1 = areas_part1.sort()[-1],
  part2 = areas_part2.sort()[-1],
}
