let corners = [
  for line in std.read_file_utf8("input.txt").split_lines():
  line.split(",").map(x => x.parse_int())
];

let abs = x => if x < 0: -x else: x;
let minmax = (x, y) => if x < y: [x, y] else: [y, x];

let areas_part1 = [
  for i, c1 in corners.enumerate():
  for j in std.range(i + 1, corners.len()):
  let c2 = corners[j];
  let w = abs(c2[0] - c1[0]) + 1;
  let h = abs(c2[1] - c1[1]) + 1;
  w * h
];

// Rename the coordinates to the minimal distinct set. In a sense we turn every
// rectangle in the map into a single cell. This helps to reduce the cardinality
// of the cells, and makes a flood fill feasible.
let rename = f => [for x in {for p in corners: f(p)}: x].enumerate();
let invert = m => { for k, v in m: v: k };
let xs = rename(p => p[0]);
let ys = rename(p => p[1]);
let xs_inv = invert(xs);
let ys_inv = invert(ys);

let corners_pack = [for p in corners: [xs_inv[p[0]], ys_inv[p[1]]]];

// Horizontal or vertical connections between two endpoints.
// Excludes the endpoints themselves.
let path = (c1, c2) =>
  if c2[0] == c1[0]:
    let bounds = minmax(c1[1], c2[1]);
    std.range(bounds[0] + 1, bounds[1]).map(y => [c1[0], y])
  else:
    let bounds = minmax(c1[0], c2[0]);
    std.range(bounds[0] + 1, bounds[1]).map(x => [x, c1[1]]);

let outline = {
  for i, c2 in corners_pack.enumerate():
  let c1 = corners_pack[i - 1];
  ..path(c1, c2),
  ..corners_pack,
};

// Now we compute a flood-fill of the outer region.
let w = xs.len();
let h = ys.len();
let offsets = [
  for dx in [-1, 0, 1]:
  for dy in [-1, 0, 1]:
  if dx != dy:
  [dx, dy]
];

// Grow the frontier by one step.
let iter = (closed, frontier)  => {
    closed = { ..closed, ..frontier },
    frontier = {
      for p in frontier:
      for d in offsets:

      let qx = p[0] + d[0];
      if qx >= (-1):
      if qx <= w:

      let qy = p[1] + d[1];
      if qy >= (-1):
      if qy <= h:

      let q = [qx, qy];
      if not frontier.contains(q):
      if not closed.contains(q):
      if not outline.contains(q):
      q
    },
  };

// We could seed the frontier with just (0, 0), but then it grows more slowly at
// every step; if we seed it with all corners it converges faster. If we seed it
// with the full outline then it would grow even faster, but in the end either
// step counts towards the RCL evaluation budget so that doesn't really help.
// The number of iterations that we need has been chosen to be just above what
// we need in order to converge and not violate the assertion below.
let n_iters = 350;
let seed_frontier = { [0, 0], [0, h], [w, h], [w, 0] };
let fixed_point_state = std
  .range(0, n_iters)
  .fold(
    { closed = std.empty_set, frontier = seed_frontier },
    (state, _i) => iter(state.closed, state.frontier),
  );

assert fixed_point_state.frontier.len() == 0: {
  error = "At a fixed point the frontier should be empty.",
  frontier = fixed_point_state.frontier,
};

// All grid points outside of our intended shape.
let outer = fixed_point_state.closed;

let is_inside = (c1, c2) =>
  let xs = minmax(c1[0], c2[0]);
  let ys = minmax(c1[1], c2[1]);
  let points = [
    for x in std.range(xs[0], xs[1] + 1):
    for y in std.range(ys[0], ys[1] + 1):
    [x, y]
  ];
  not points.any(outer.contains);

let areas_part2 = [
  for i, c1 in corners_pack.enumerate():
  for j in std.range(i + 1, corners_pack.len()):
  let c2 = corners_pack[j];
  if is_inside(c1, c2):
  let x1 = xs[c1[0]];
  let x2 = xs[c2[0]];
  let y1 = ys[c1[1]];
  let y2 = ys[c2[1]];
  let w = abs(x2 - x1) + 1;
  let h = abs(y2 - y1) + 1;
  w * h
];

{
  part1 = areas_part1.sort()[-1],
  part2 = areas_part2.sort()[-1],
}
