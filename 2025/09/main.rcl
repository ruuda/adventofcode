let corners = [
  for line in std.read_file_utf8("input.txt").split_lines():
  line.split(",").map(x => x.parse_int())
];

let abs = x => if x < 0: -x else: x;
let minmax = (x, y) => if x < y: [x, y] else: [y, x];

// Rename the coordinates to the minimal distinct set. In a sense we turn every
// rectangle in the map into a single cell. This helps to reduce the cardinality
// of the cells, and makes a flood fill feasible.
let rename = f => [for x in {for p in corners: f(p)}: x].enumerate();
let invert = m => { for k, v in m: v: k };
let xs = rename(p => p[0]);
let ys = rename(p => p[1]);
let xs_inv = invert(xs);
let ys_inv = invert(ys);
let corners_pack = [for p in corners: [xs_inv[p[0]], ys_inv[p[1]]]];

// For part 1, compute all possible rectangles by descending size. We keep the
// corners, because we'll use the same rectangles in part 2.
let areas = [
  for i, c1 in corners.enumerate():
  for j in std.range(i + 1, corners.len()):
  let c2 = corners[j];
  let w = abs(c2[0] - c1[0]) + 1;
  let h = abs(c2[1] - c1[1]) + 1;
  [w * h, c1, c2]
];
let areas_desc = areas.sort().reverse();

// The idea for part 2: we flood-fill the map, starting from the outside, using
// the outline of the shape as a barrier. Then later we check if any of the
// rectangles overlap with any of the cells that are part of the exterior.

// Horizontal or vertical connections between two endpoints.
// Excludes the endpoints themselves.
let path = (c1, c2) =>
  if c2[0] == c1[0]:
    let bounds = minmax(c1[1], c2[1]);
    std.range(bounds[0] + 1, bounds[1]).map(y => [c1[0], y])
  else:
    let bounds = minmax(c1[0], c2[0]);
    std.range(bounds[0] + 1, bounds[1]).map(x => [x, c1[1]]);

// The outline of the shape defined by the corners.
let outline = {
  for i, c2 in corners_pack.enumerate():
  let c1 = corners_pack[i - 1];
  ..path(c1, c2),
  ..corners_pack,
};

let w = xs.len();
let h = ys.len();
let offsets = [
  for dx in [-1, 0, 1]:
  for dy in [-1, 0, 1]:
  if dx != dy:
  [dx, dy]
];

// All grid points outside of our intended shape.
let exterior = {[w, h]}
  .transitive_closure(
    p => {
      for d in offsets:

      let qx = p[0] + d[0];
      if qx >= (-1):
      if qx <= w:

      let qy = p[1] + d[1];
      if qy >= (-1):
      if qy <= h:

      let q = [qx, qy];
      if not outline.contains(q):
      q
    },
  );

// Given bounds [xmin, xmax], [ymin, ymax], is the rect fully inside the shape?
// The way this is written is not the clearest, but by using `.all` on rows and
// then on columns, we get early-out behavior, which helps to stay within the
// evaluation budget.
let is_inside = (xs, ys) => std
  .range(ys[0], ys[1] + 1)
  .all(y => std.range(xs[0], xs[1] + 1).all(x => not exterior.contains([x, y])));

let areas_part2 = [
  // Here I'm going to cheat a bit. If we scan the full range, then we hit the
  // evaluation budget. But we can scan *part* of the range, see if the solution
  // is in that part, if not, check the next part, etc. until we find the answer.
  for i in std.range(47_000, 50_100):
  let item = areas_desc[i];
  let c1 = item[1];
  let c2 = item[2];
  let xs = minmax(xs_inv[c1[0]], xs_inv[c2[0]]);
  let ys = minmax(ys_inv[c1[1]], ys_inv[c2[1]]);
  if is_inside(xs, ys):
  item[0]
];

{
  part1 = areas_desc[0][0],
  part2 = areas_part2[0],
}
